start = 
  element snmptrace {
    packet.elem*
  }

packet.elem = 
  element packet {
    attribute sec { xsd:unsignedInt },
    attribute usec { xsd:unsignedInt },
    element src { addr.attrs },
    element dst { addr.attrs },
    snmp.elem
  }

snmp.elem = 
  element snmp {
    length.attrs?,
    message.elem
  }

message.elem =
  element version { length.attrs, xsd:int },
  element community { length.attrs, xsd:hexBinary },
  pdu.elem

message.elem |=
  element version { length.attrs, xsd:int },
  element message {
    length.attrs,
    element msg-id { length.attrs, xsd:unsignedInt },
    element max-size { length.attrs, xsd:unsignedInt },
    element flags { length.attrs, xsd:hexBinary },
    element security-model { length.attrs, xsd:unsignedInt },
    usm.elem?
  },
  element scoped-pdu {
    length.attrs,
    element context-engine-id { length.attrs, xsd:hexBinary },
    element context-name { length.attrs, xsd:string },
    pdu.elem
  }

usm.elem =
  length.attrs,
  element auth-engine-id { length.attrs, xsd:hexBinary },
  element auth-engine-boots { length.attrs, xsd:unsignedInt },
  element auth-engine-time { length.attrs, xsd:unsignedInt },
  element user { length.attrs, xsd:string },
  element auth-params { length.attrs, xsd:hexBinary },
  element priv-params { length.attrs, xsd:hexBinary }

pdu.elem =
  element trap { 
    length.attrs,
    element enterprise { length.attrs, oid.type },
    element agent-addr { length.attrs, ipaddress.type },
    element generic-trap { length.attrs, xsd:int },
    element specific-trap { length.attrs, xsd:int },
    element time-stamp { length.attrs, xsd:int },
    element variable-bindings { length.attrs, varbind.elem* }
  }

pdu.elem |=
  element (get-request | get-next-request | get-bulk-request |
           set-request | inform | trap2 | response | report) { 
    length.attrs,
    element request-id { length.attrs, xsd:int },
    element error-status { length.attrs, xsd:int },
    element error-index { length.attrs, xsd:int },
    element variable-bindings { length.attrs, varbind.elem* }
  }

varbind.elem = 
  element varbind { length.attrs, name.elem, value.elem }

name.elem =
  element name { length.attrs, oid.type }

value.elem =
  element null { length.attrs, empty } |
  element integer32 { length.attrs, xsd:int } |
  element unsigned32 { length.attrs, xsd:unsignedInt } |
  element unsigned64 { length.attrs, xsd:unsignedLong } |
  element ipaddress { length.attrs, ipaddress.type } |
  element octet-string { length.attrs, xsd:hexBinary } |
  element object-identifier { length.attrs, oid.type } |
  element (no-such-object | no-such-instance | end-of-mib-view) { empty }

# The blen attribute indicates the number of bytes used by the BER
# encoded tag / length / value triple. The vlen attribute indicates
# the number of bytes used by the BER encoded value alone.

length.attrs =
  ( attribute blen { xsd:unsignedShort },
    attribute vlen { xsd:unsignedShort } )?

addr.attrs =
  attribute ip { ipaddress.type },
  attribute port { xsd:unsignedShort }

oid.type =
  xsd:string {
    pattern =
      """[0-2](\.[0-9]+)+"""
  }

# Someone should extend the regular expression below to cover also
# IPv6 addresses (including zone indexes ;-).

ipaddress.type =
  xsd:string {
    pattern =
      """[0-9]*\.[0-9]*\.[0-9]*\.[0-9]*"""
  }
