<?xml version="1.0"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc symrefs="yes"?> 
<!-- full3978 -->
<rfc ipr='full3978' 
     docName="draft-irtf-nmrg-snmp-trace-definitions-00.txt"
     category="info">

  <!--
  $Id: measure.xml 2374 2007-06-28 20:01:18Z schoenw $
  -->

  <!--
      TODO:
        - treat all traps (v1 and v2) in the same ways !?
        - we currently ignore message versions - do we keep this?
  -->

  <front>

    <title abbrev="SNMP Trace Analysis Definitions">
      SNMP Trace Analysis Definitions
    </title>
    
    <author initials="G." surname="van den Broek"
            fullname="Gijs van den Broek">
      <organization>University of Twente</organization>
      <address>
        <postal>
          <street>P.O. BOX 217</street>
          <city>7500 AE Enschede</city>
          <country>Netherlands</country>
        </postal>
        <phone></phone>
        <email>j.g.vandenbroek@student.utwente.nl</email>
      </address>
    </author>

    <author initials="J." surname="Schoenwaelder"
            fullname="Juergen Schoenwaelder">
      <organization>Jacobs University Bremen</organization>
      <address>
        <postal>
          <street>Campus Ring 1</street>
          <city>28725 Bremen</city>
          <country>Germany</country>
        </postal>
        <phone>+49 421 200-3587</phone>
        <email>j.schoenwaelder@jacobs-university.de</email>
      </address>
    </author>

    <author initials="A." surname="Pras"
            fullname="Aiko Pras">
      <organization>University of Twente</organization>
      <address>
        <postal>
          <street>P.O. BOX 217</street>
          <city>7500 AE Enschede</city>
          <country>Netherlands</country>
        </postal>
        <phone>+31 53 4893778</phone>
        <email>a.pras@cs.utwente.nl</email>
      </address>
    </author>

    <author initials="M." surname="Harvan"
            fullname="Matus Harvan">
      <organization>ETH Zurich</organization>
      <address>
        <postal>
          <street>ETH Zentrum</street>
          <city>8092 Zurich</city>
          <country>Switzerland</country>
        </postal>
        <phone>+41 44 632 68 76</phone>
        <email>mharvan@inf.ethz.ch</email>
      </address>
    </author>

    <date month="December" year="2007"/>

      <area>Operations and Management</area>

      <workgroup>NMRG</workgroup>

      <keyword>Network Management</keyword>
      <keyword>Simple Network Management Protocol</keyword>
      <keyword>SNMP</keyword>

      <abstract>
        <t>
          The Network Management Research Group (NMRG) started an
          activity to collect traces of the Simple Network Management
          Protocol (SNMP) from operational networks. To analyze these
          traces, it is necessary to split potentially large traces
          into more manageable pieces that make it easier to deal
          with large data sets and simplify the analysis of the data.
        </t>
        <t>
          This document provides some common definitions that have
          been found useful for implementing tools to support trace
          analysis. This document mainly serves as a reference for the
          definitions underlying these tools and it is not meant to
          explain all the motivation and reasoning behind the
          definitions. Some of this background information can be
          found in other research papers.
        </t>
      </abstract>

  </front>



  <middle>



    <section anchor="introduction" title="Introduction">
      <t>
        The Network Management Research Group (NMRG) started an
        activity to collect traces of the Simple Network Management
        Protocol (SNMP) <xref target="RFC3410"/>
        <xref target="RFC3411"/> from operational networks. To analyze
        these traces, it is necessary to split potentially large
        traces into more manageable pieces that make it easier to
        deal with large data sets and simplify the analysis of the
        data.
      </t>
      <t>
        This document provides some common definitions that have been
        found useful for implementing tools to support trace
        analysis. This document mainly serves as a reference for the
        definitions underlying these tools and it is not meant to
        explain all the motivation and reasoning behind the
        definitions. Some of this background information can be found
        in other research papers.
      </t>
      <t>
        More information and the motivation for SNMP trace collection
        and analysis can be found in RFC XXXX <xref
        target="ID-IRTF-NMRG-SNMP-MEASURE-01"/>.
      </t>
    </section>

    <section anchor="overview" title="Overview">
      <t>
        The following diagram provides and overview over the following
        definitions and how they are related to each other.
      </t>
      <figure>
      <artwork><![CDATA[
        +----------------+ 1     1..* +-----------+
        | Slice Set Type |------------| Slice Set |
        +----------------+  <of_type  +-----------+
                                             | 1
                                             |
                                             | ^belongs_to
                                             |
                                             | 1..*
+-------+ 1     0..* +------+ 1     0..* +-------+
| Trace |------------| Flow |------------| Slice | 
+-------+  contains> +------+  contains> +-------+
                                             ^
                                             | ^is_a
                                             |
                                         +-------+
                                         | Walk  |
                                         +-------+
                                           ^   ^
                   +-----------------------+   |
                   |                           |
            +-------------+     +-------------------------+
            | Strict Walk |     | Prefix Constrained Walk |
            +-------------+     +-------------------------+      
      ]]></artwork>
      </figure>
      <t>
        In this document are names assigned to SNMP messages containing
        specific PDU types. These messages are part of a large set of
        SNMP messages, called a trace. A trace contains SNMP messages
        exchanged between possibly many different managers and agents.
        Such a trace may consist of one or more flows which contain only
        those messages that are exchanged between two network endpoints.
        Even smaller are slices, which are part of a flow and contain
        SNMP messages that are related to each other in time and referenced
        information. [TODO: I find this text somewhat confusing; I think it
        needs a rewrite. Shall we add Messages to the diagram?]
      </t>
      <t>
        Slices can be of a specific form, e.g., a sequence of linked
        getnext or getbulk requests commonly called a walk. Only a
        subset of all slices will be walks. In some cases, a slice may
        not only be regarded as a walk, but also even as a strict walk
        or a prefix constrained walk.
      </t>
      <t>
        On or more individual slices, which are part of one or more
        flows, may all be related to each other as a result of, for
        example, a manager polling a number of agents every few
        minutes. All slices making up such a polling instance would
        form a slice set. In turn, comparable slice sets will be of
        the same slice set type.
      </t>
    </section>

    <section anchor="messages" title="Messages">

      <t>
        SNMP messages carry PDUs associated with well defined specific
        protocol operations <xref target="RFC3416"/>. The PDUs can be
        used to classify SNMP messages. Following are a number of
        definitions that help to classify SNMP messages based on the
        PDU contained in them. These definitions will be used later on
        in this document.
      </t>
      <t>
        Notation: Let M be a message. We denote the properties of M as
        follows:
      </t>
      <figure>
      <artwork><![CDATA[
   M.type    = operation type of message M (get, getnext, ...)
   M.class   = class of message M (according to RFC 3411)
   M.tsrc    = transport layer source endpoint of message M
   M.tdst    = transport layer destination endpoint of message M
   M.nsrc    = network layer source endpoint of message M
   M.ndst    = network layer destination endpoint of message M
   M.reqid   = request identifier of message M
   M.time    = capture timestamp of message M
   M.oids    = OIDs listed in varbind list of message M
   M.values  = values listed in varbind list of message M
   ]]></artwork>
      </figure>
      <t>
        Note that the properties of a message can be easily extracted
        from the exchange formats defined in RFC XXXX
        <xref target="ID-IRTF-NMRG-SNMP-MEASURE-01"/>.
      </t>

      <t>
        Definition (read request message): A read request message is a
        message M containing a PDU of type GetRequest, GetNextRequest,
        or GetBulkRequest.
      </t>

      <t>
        Definition (write request message): A write request message is
        a message M containing a PDU of type SetRequest.
      </t>

      <t>
        Definition (notification request message): A notification
        request message is a message M containing a PDU of type
        InformRequest.
      </t>

      <t>
        Definition (notification message): A notification message is a
        message M containing a PDU of type Trap or InformRequest.
      </t>

      <t>
        Definition (request message): A request message is a message M
        which is either a read request message, a write request
        message, or a notification request message.
      </t>
      
      <t>
        Definition (response message): A response message is a message
        M containing a PDU of type Response or of type Report.
      </t>

      <t>
        Note that Report messages are treated like Response messages
        since the SNMPv3 specifications currently use Report messages
        only as an error reporting mechanism, always triggered by the
        processing of some request messages. In case future SNMP
        versions or extensions use Report messages without having a
        request triggering the generation of Report messages, we may
        have to revisit the definition above.
      </t>

      <t>
        Definition (non-response message): A non-response message is a
        message M which is either a read request message, a write
        request message, or a notification message.
      </t>

      <t>
        Definition (command message): A command message is a message M
        which is either a read request message or a write request
        message.
      </t>

      <t>
        Definition (command group messages): A set of command group
        messages consists of all messages M satisfying either of the
        following two conditions:
      </t>
      <t>
        <list style='format (C%d) ' counter='command'>
          <t>M is a command message</t>
          <t>M is a response message and there exists a command
          message C such that the following holds:
          <figure>
            <artwork><![CDATA[
          M.reqid = C.reqid
          M.tdst  = C.tsrc
          M.tsrc  = C.tdst
          (M.time - C.time) < t
          ]]></artwork>
            </figure>
          </t>
        </list>
      </t>
      <t>
        The parameter t defines a maximum timeout for response messages.
      </t>

      <t>
        Note that this definition requires that the response message
        originates from the transport endpoint over which the request
        message has been received. This is not strictly required by
        SNMP transport mappings and in particular the UDP transport
        mapping allows to send responses from different transport
        endpoints. While sending response messages from a different
        transport endpoint is legal, it is also considered bad
        practice causing interoperability problems since several
        management systems do not accept such messages.
      </t>
      <t>
        It was decided to require matching transport endpoints since
        doing so significantly simplifies the procedures below and
        avoids accidentally confusing requests and responses.
        Implementations responding from different transport endpoints
        will lead to (a) a larger number of requests without related
        responses (and likely no retries) and (b) a similarly large
        number of response messages without a matching request. If
        such behavior can be detected, the traces should be
        investigated and if needed the transport endpoints corrected.
      </t>

      <t>
        Definition (notification group messages): A set of group
        notification messages consists of all messages M satisfying
        either of the following two conditions:
      </t>
      <t>
        <list style='format (N%d) ' counter='notification'>
          <t>M is a notification message</t>
          <t>M is a response message and there exists a notification
          request message N such that the following holds:
            <figure>
              <artwork><![CDATA[
          M.reqid = N.reqid
          M.tdst  = N.tsrc
          M.tsrc  = N.tdst
          (M.time - N.time) < t
          ]]></artwork>
            </figure>
          </t>
        </list>
      </t>
      <t>
        The parameter t defines a maximum timeout for response messages.
      </t>

      <t>
        Note that we again require that the transport endpoints match
        for notification group messages.
      </t>

    </section>

    <section anchor="traces" title="Traces">
      <t>
        Traces are (large) sets of SNMP messages that are the result
        of recording SNMP traffic using a single traffic recording
        unit (e.g., using tcpdump) on a network segment carrying
        traffic of one or more managers and agents. Traces being used
        in the remainder of this document may be altered as a result
        of anonymization, which may result in some message information
        loss.
      </t>
      <t>
        Definition (trace): An SNMP trace (or short trace) T is an
        ordered set of zero or more SNMP messages M for which the
        following holds:
      </t>
      <t>
        <list style='format (T%d) ' counter='notification'>
          <t>
            Each messages M in T is either a non-response message or a
            response message.
          </t>
          <t>
            All messages M in T are chronologically ordered according
            to the capture time stamp M.time.
          </t>
        </list>
      </t>
    </section>

    <section anchor="flows" title="Flows">
      <t>
        Definition (flow): A flow F is the set of messages of an SNMP
        trace T with the following properties:
      </t>
      <t>
        <list style='format (F%d) ' counter='flow'>
          <t>
            All response messages originate from a single network
            endpoint.
          </t>
          <t>
            All non-response messages originate from a single network
            endpoint.
          </t>
          <t>
            All messages are either command group messages or
            notification group messages.
          </t>
        </list>
      </t>
      <t>
        Subsequently, we call flows containing only command group
        messages command flows. Similarly, we call flows containing
        only notification group messages notification flows.
      </t>
      <t>
        Note that it is possible that response messages of a trace
        cannot be classified to belong to any flow. This can happen if
        request messages triggering the response messages were not
        recorded (for example due to asymmetric routing) or because
        response messages were originating from transport endpoints
        different from the endpoint used to receive the associated
        request message.
      </t>
      <t>
        Definition (flow initiator): A flow initiator is the network
        endpoint of the two endpoints involved in a flow, which is
        responsible for sending the first non-response message.
      </t>
      <t>
        Notation: Let F be a flow as defined above. We denote the
        properties of F as follows:
      </t>
      <figure>
      <artwork><![CDATA[
   F.type  = type of the flow F (command/notification)
   F.nsrc  = network layer source endpoint of F
   F.ndst  = network layer destination endpoint of F
   F.start = time stamp of the first message in F
   F.end   = time stamp of the last message in F
   ]]></artwork>
      </figure>
      <t>
        This definition of a flow is mostly consistent with the
        definition of a flow used in <xref target="SPHSM07"/>. The
        difference is that the tool used to generate the data reported
        in <xref target="SPHSM07"/> did only require that the network
        layer source endpoint of the response messages matches the
        destination network layer endpoint of the associated request
        messages.
      </t>
    </section>

    <section anchor="slices" title="Slices">

      <t>
        Flows are made up of smaller sets of messages that are related
        to each other. Such a subset of messages from a single flow
        will be considered a slice of a flow.
      </t>
      <t>
        Definition (slice): A slice S is a subset of messages in a
        flow F for which the following properties hold:
      </t>
      <t>
        <list style='format (S%d) ' counter='slice'>
          <t>
            All messages are exchanged between the same two transport
            endpoints (a single transport endpoint pair).
          </t>
          <t>
            All non-response messages must be of the same type.
          </t>
          <t>
            All messages with a PDU of type Get, Set, Trap, or Inform
            must contain the same set of OIDs.
          </t>
          <t>
            Each GetNext or GetBulk message must either contain the
            same set of OIDs or they must be linked to the
            chronologically last response of the previous request,
            that is the request must contain at least one OID that has
            been contained in the (repeater) varbind list of the
            chronologically last response message of a previous
            request message.
          </t>
          <t>
            All Response messages must follow a previous request
            message that is part of the same slice.
          </t>
          <t>
            For any two subsequent request messages Q1 and Q2 with
            Q1.time &lt; Q2.time, the following condition must hold:
            <figure>
              <artwork><![CDATA[
            (Q2.time - Q1.time) < e
            ]]></artwork>
            </figure>
          </t>
        </list>
      </t>

      <t>
        The parameter e defines a maximum time between two request
        messages that belong to a slice.  This parameter should be
        chosen such that unrelated requests within a flow are
        considered to be of the same slice. This might, for example,
        be the case where an agent never responds to requests from a
        manager that is set to poll that agent on a periodic basis.
      </t>

      <t>
        Definition (slice initiator): A slice initiator is one of the
        two transport endpoints involved in a slice, which is
        responsible for sending the chronologically first non-response
        class message.
      </t>

      <t>
        Notation: A slice S has several properties. We introduce the
        following notation:
      </t>
      <figure>
        <artwork><![CDATA[
   S.type     = type of non-response messages in S
   S.tsrc     = transport layer endpoint of initiator of S
   S.tdst     = transport layer endpoint of non-initiator of S
   S.start    = time stamp of the chronologically first message in S
   S.end      = time stamp of the chronologically last message in S
   S.prefix   = prefix of S (see below)
   ]]></artwork>
      </figure>
      <t>
        Definition (concurrency): Two slides A and B of a given flow F
        are concurrent at time t if A.start &lt;= t &lt;= A.end and
        B.start &lt;= t &lt;= B.end. The concurrency level F.clevel(t)
        of a flow F at time t is given by the number of concurrent
        slices of F at time t. The concurrency level of a manager
        identified by the network address addr at time t is given by
        the sum of the flow currency levels F.clevel(t) for all flows
        originating from addr, that is F.nsrc = addr.
      </t>
      <t>
        Definition (delta time serial): Two slides A and B of a given
        flow F are called delta time serial if (B.start - A.end) &lt;
        delta.
      </t>

    </section>

    <section anchor="slice-prefix" title="Slice Prefix - (more thoughts needed)">

      <t>
        Definition (slice prefix): A slice prefix P is a set of OID
        prefixes derived from the OIDs containted in the non-response
        messages of a slice.  This set P consists of the following
        OIDs:
        <list style='format (SP%d) ' counter='sliceprefix'>
          <t>
            Each OID x in a non-response message C2 of a slice that is
            not in any of the response messages R of the previous
            non-response message C1, where R.time &lt; C2.time for
            each of these response messages, must hold that x is not
            already in P and there exists no OID in P that makes up a
            part (starting from the beginning) of x.
          </t>
        </list>
      </t>
      
      <t>
        [I am not sure this is clear yet. Do we need some examples?
         Or shall we specify this with some pseudo code?]
      </t>

      <t>
        The slice prefix allows for comparing/differentiating between
        individual slices.
      </t>

    </section>

    <section anchor="slice-sets" title="Slice Sets - (more thoughts needed)">

      <t>
        Definition (slice type): A slice type is a type mark
        identifying slices that share the following properties:
      </t>
      <t>
        <list style='format (ST%d) ' counter='slicetype'>
          <t>
            All messages have been exchanged between the same
            transport endpoints.
          </t>
          <t>
            All read request messages, write request messages, and
            notification messages originate from the same transport
            endpoint.
          </t>
          <t>
            All non-response messages are of the same type
          </t>
        </list>
      </t>
      <t>
        [TODO: Should this be an equivalence relation so that slice
        sets turn into equivalent classes?]
      </t>
      <t>
        Definition (slice set): A slice set is a set of slices that
        have the following properties:
      </t>
      <t>
        <list style='format (SS%d) ' counter='sliceset'>
          <t>
            All READ, WRITE, NOTIFY messages originate from the same
            transport endpoint. (really transport???)
          </t>
          <t>???</t>
          <t>All messages occurred within a specific time frame of
            each other. (what does this mean??? do we need delta
            serial for messages???)
          </t>
        </list>
      </t>

    </section>

    <section anchor="walks" title="Walks - (more thoughts needed)">

      <t>
        Definition (walk): A walk W is a slice S with the following
        properties:
      </t>
      <t>
        <list style='format (W%d) ' counter='walk'>
          <t>
            The type of the slice S is either get-next-request or
            get-bulk-request.
          </t>
          <t>
            At least one object identifier in the sequence of requests
            at the same varbind index must be increasing
            lexicographically while all object identifiers at the same
            varbind index have to be non-decreasing.
          </t>
        </list>
      </t>

      <t>
        Definition (strict walk): A walk W is a strict walk if all
        object identifiers in the sequence of requests at the same
        varbind index are strictly increasing lexicographically.
        Furthermore, the object identifiers at the same index of a
        response and a subsequent request must be identical.
      </t>

      <t>
        Definition (prefix constrained walk): A walk W is prefix
        constrained if all object identifiers at the same index have
        the same object identifier prefix.  This prefix is established
        by the first request within the walk.
      </t>

    </section>


    <section anchor="security" title="Security Considerations">
      <t>
        This document provides definitions for the analysis of SNMP
        traces and does not impact the security of the Internet.
      </t>
    </section>

    <section title="Acknowledgements">
      <t>
        This document was influenced by discussions within the Network
        Management Research Group (NMRG).
      </t>
      <t>
        Part of this work was funded by the European Commission under
        grant FP6-2004-IST-4-EMANICS-026854-NOE.
      </t>
    </section>

  </middle>



  <back>


    <references title="Normative References">

      <reference anchor="RFC3411">
        <front>
          <title>
            An Architecture for Describing Simple Network Management
            Protocol (SNMP) Management Frameworks
          </title>
          <author initials="D." surname="Harrington" fullname="D. Harrington">
            <organization>Enterasys Networks</organization>
          </author>
          <author initials="R." surname="Presuhn" fullname="R. Presuhn">
            <organization>BMC Software, Inc.</organization>
          </author>
          <author initials="B." surname="Wijnen" fullname="B. Wijnen">
            <organization>Lucent Technologies</organization>
          </author>
          <date month="December" year="2002"/>
        </front>
        <seriesInfo name="RFC" value="3411"/>
      </reference>

      <reference anchor="RFC3416">
        <front>
          <title>
            Version 2 of the Protocol Operations for
            the Simple Network Management Protocol (SNMP)
          </title>
          <author initials="R." surname="Presuhn" fullname="R. Presuhn">
            <organization>BMC Software, Inc.</organization>
          </author>
          <date month="December" year="2002"/>
        </front>
        <seriesInfo name="RFC" value="3416"/>
      </reference>

    </references>


    <references title="Informative References">

      <reference anchor="RFC3410">
        <front>
          <title>
            Introduction and Applicability Statements for
            Internet Standard Management Framework
          </title>
          <author initials="J." surname="Case" fullname="J. Case">
            <organization>SNMP Research, Inc.</organization>
          </author>
          <author initials="R." surname="Mundy" fullname="R. Mundy">
            <organization>Network Associates Laboratories</organization>
          </author>
          <author initials="D." surname="Partain" fullname="D. Partain">
            <organization>Ericsson</organization>
          </author>
          <author initials="B." surname="Stewart" fullname="B. Stewart">
            <organization>Retired</organization>
          </author>
          <date month="December" year="2002"/>
        </front>
        <seriesInfo name="RFC" value="3410"/>
      </reference>

      <reference anchor="ID-IRTF-NMRG-SNMP-MEASURE-01">
        <front>
          <title>
            An Architecture for Describing Simple Network Management
            Protocol (SNMP) Management Frameworks
          </title>
          <author initials="J." surname="Schoenwaelder" fullname="Juergen Schoenwaelder">
            <organization>TU Braunschweig</organization>
          </author>
          <date month="January" year="2007"/>
        </front>
        <seriesInfo name="ID" value="draft-irtf-nmrg-snmp-measure-01.txt"/>
      </reference>

      <reference anchor="SPHSM07">
        <front>
          <title>
            SNMP Traffic Analysis: Approaches, Tools, and First Results
          </title>
          <author initials="J." surname="Schoenwaelder" fullname="Juergen Schoenwaelder">
            <organization>TU Braunschweig</organization>
          </author>
          <author initials="A." surname="Pras" fullname="A. Pras">
            <organization>University of Twente</organization>
          </author>
          <author initials="M." surname="Harvan" fullname="M. Harvan">
            <organization>International University Bremen</organization>
          </author>
          <author initials="J." surname="Schippers" fullname="J. Schippers">
            <organization>University of Twente</organization>
          </author>
          <author initials="R." surname="van de Meent" fullname="R. van de Meent">
            <organization>University of Twente</organization>
          </author>
          <date month="May" year="2007"/>
        </front>
        <seriesInfo name="IFIP/IEEE Integrated Management" value="IM 2007"/>
      </reference>

    </references>

  </back>
    

</rfc>

<!-- Local Variables:                                           -->
<!-- compile-command: "xml2rfc definitions.xml"                 -->
<!-- ispell-local-dictionary: "american"                        -->
<!-- sgml-declaration: "/usr/lib/sgml/declaration/xml.decl"     -->
<!-- sgml-omittag:nil                                           -->
<!-- sgml-shorttag:t                                            -->
<!-- sgml-namecase-general:t                                    -->
<!-- sgml-minimize-attributes:nil                               -->
<!-- sgml-always-quote-attributes:t                             -->
<!-- sgml-indent-step:2                                         -->
<!-- sgml-indent-data:t                                         -->
<!-- sgml-parent-document:nil                                   -->
<!-- sgml-exposed-tags:nil                                      -->
<!-- sgml-local-catalogs:nil                                    -->
<!-- sgml-local-ecat-files:nil                                  -->
<!-- End:                                                       -->
