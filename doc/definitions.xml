<?xml version="1.0"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc symrefs="yes"?> 
<!-- full3978 -->
<rfc ipr='full3978' 
     docName="draft-schoenw-nmrg-snmp-trace-definitions-02.txt ($Rev: 2846 $)"
     category="info">

  <!--
  $Id: measure.xml 2374 2007-06-28 20:01:18Z schoenw $
  -->

  <!--
      TODO:
        - treat all traps (v1 and v2) in the same ways !?
        - we currently ignore message versions - do we keep this?
  -->

  <front>

    <title abbrev="SNMP Trace Analysis Definitions">
      SNMP Trace Analysis Definitions
    </title>
    
    <author initials="J. G." surname="van den Broek"
            fullname="Jurgen Gijs van den Broek">
      <organization>University of Twente</organization>
      <address>
        <postal>
          <street>P.O. BOX 217</street>
          <city>7500 AE Enschede</city>
          <country>Netherlands</country>
        </postal>
        <phone>+31 6 13506591</phone>
        <email>j.g.vandenbroek@student.utwente.nl</email>
      </address>
    </author>

    <author initials="J." surname="Schoenwaelder"
            fullname="Juergen Schoenwaelder">
      <organization>Jacobs University Bremen</organization>
      <address>
        <postal>
          <street>Campus Ring 1</street>
          <city>28725 Bremen</city>
          <country>Germany</country>
        </postal>
        <phone>+49 421 200-3587</phone>
        <email>j.schoenwaelder@jacobs-university.de</email>
      </address>
    </author>

    <author initials="A." surname="Pras"
            fullname="Aiko Pras">
      <organization>University of Twente</organization>
      <address>
        <postal>
          <street>P.O. BOX 217</street>
          <city>7500 AE Enschede</city>
          <country>Netherlands</country>
        </postal>
        <phone>+31 53 4893778</phone>
        <email>a.pras@cs.utwente.nl</email>
      </address>
    </author>

    <author initials="M." surname="Harvan"
            fullname="Matus Harvan">
      <organization>ETH Zurich</organization>
      <address>
        <postal>
          <street>ETH Zentrum</street>
          <city>8092 Zurich</city>
          <country>Switzerland</country>
        </postal>
        <phone>+41 44 632 68 76</phone>
        <email>mharvan@inf.ethz.ch</email>
      </address>
    </author>

    <date month="April" year="2008"/>

      <area>Operations and Management</area>

      <workgroup>NMRG</workgroup>

      <keyword>Network Management</keyword>
      <keyword>Simple Network Management Protocol</keyword>
      <keyword>SNMP</keyword>

      <abstract>
        <t>
          The Network Management Research Group (NMRG) started an
          activity to collect traces of the Simple Network Management
          Protocol (SNMP) from operational networks. To analyze these
          traces, it is necessary to split potentially large traces
          into more manageable pieces that make it easier to deal
          with large data sets and simplify the analysis of the data.
        </t>
        <t>
          This document provides some common definitions that have
          been found useful for implementing tools to support trace
          analysis. This document mainly serves as a reference for the
          definitions underlying these tools and it is not meant to
          explain all the motivation and reasoning behind the
          definitions. Some of this background information can be
          found in other research papers.
        </t>
      </abstract>

  </front>



  <middle>



    <section anchor="introduction" title="Introduction">
      <t>
        The Simple Network Management Protocol (SMMP) was introduced
        in the late 1980s. Since then, several protocol changes have
        taken place, which have eventually led to what is known today
        as the SNMP version 3 framework (SNMPv3) <xref
        target="RFC3410"/><xref target="RFC3411"/>. Extensive use of
        SNMP has led to significant practical experience by both
        network operators and researchers. However, up until now only
        little research has been done on characterizing and modeling
        SNMP traffic.
      </t>
      <t>
        Since recently, network researchers are in the possession of
        network traces, including SNMP traces captured on operational
        networks. The availability of SNMP traces enables research on
        characterizing and modeling real world SNMP traffic. However,
        experience with SNMP traces has shown that the traces must be
        large enough in order to make proper observations. A more
        detailed motivation for collecting SNMP traces and guidelines
	on how to capture SNMP traces can be found in <xref
        target="ID-IRTF-NMRG-SNMP-MEASURE"/>.
      </t>
      <t>
        Unfortunately, the analysis of large SNMP traces can take a
        large amount of processing time. Therefore, it is often
        desirable to focus the analysis on smaller, relevant sections
        of a trace.  This in turn requires a proper way to identify
        these smaller sections of a trace. This document describes a
        number of identifiable sections within a trace which make
        specific research on these smaller sections more practical.
        The following figure shows the various sections of traces and
        how they relate to each other.
      </t>
      <figure>
      <artwork><![CDATA[
  +---------+ 0..*      1  +-------+ 1     0..* +------+
  | Message |------------->| Trace |----------->| Flow |
  +---------+  belongs_to  +-------+  contains  +------+
                                                   | 1
                                                   |
                                                   | contains
                                                   |
                                                   v 0..*
                      +------------+ 1    0..* +-------+
                      | Slice Type |<----------| Slice |
                      +------------+  of_type  +-------+
                                                   ^ 1
                                                   |
                                                   | is_a
                                                   |
                                                   | 0..1
                                               +-------+
                                               | Walk  |
                                               +-------+
      ]]></artwork>
      </figure>
      <t>
        This document defines the various entities (boxes) shown in
        the above figure. These definitions can be implemented by
        tools that can split SNMP traces into smaller sections for
        further analysis.
      </t>
      <t>
        The most central entity in the figure above is an SNMP trace,
        consisting of a potentially large set of SNMP messages. An
        SNMP trace is the result of recording SNMP traffic on a
        specific network for a specific time duration. Such a trace
        may, depending on the number of hosts in the respective
        network, contain SNMP messages exchanged between possibly many
        different SNMP engines. The messages contained in a trace may
        be represented in different formats. For the purpose of this
        document, the simple comma separated values (CSV) format
        defined in <xref target="ID-IRTF-NMRG-SNMP-MEASURE"/> contains
        sufficient information to split a trace into smaller sections.
      </t>
      <t>
        The SNMP messages belonging to an SNMP trace may have been
        exchanged between many different SNMP engines running on
        different hosts. Therefore, a first obvious way of separating
        a trace into smaller sets of SNMP messages is the separation
        of a trace into flows. Each flow contains only those SNMP
        messages of an SNMP trace that have been exchanged between two
        network endpoints. Such a separation may be necessary in case
        one wants to analyze specific SNMP traffic characteristics
        (e.g., number of agents managed by a management station) and
        wants to rule out network endpoint specific behaviour (e.g.,
        different SNMP management stations may have different polling
        configurations).
      </t>
      <t>
        Flows within traces can still be quite large in terms of the
        number of messages they contain. Therefore, it may be
        necessary to split a flow into even smaller sections called
        slices. A slice contains all SNMP messages of a given flow
        that are related to each other in time and referenced
        information. Splitting a flow into slices makes it possible to
        separate SNMP messages within traces that belong to each
        other.
      </t>
      <t>
	For example, a slice may contain the exchanged SNMP messages
	between an agent and a manager, which polls that agent in a
	single polling instance.  The manager may be configured to
	poll that agent every once in a while. If the requested
	information from the agent remains unchanged, then the
	respective slices of SNMP traffic occurring between this
	manager and agent will be highly comparable.  In such a case
	the slices will be of the same slice type. Similar slices will
	thus be considered of the same slice type and incomparable
	slices will not be of the same slice type.
      </t>
      <t>
        Besides the fact that each slice is of specific slice type,
        slices can also be of a specific form with respect to the
        messages encompassing a slice.  For example, slices containing
        a sequence of linked GetNext or GetBulk requests are commonly
        called an SNMP walk.  Note that only a subset of all slices
        will be walks.
      </t>
    </section>

    <section anchor="messages" title="Messages">

      <t>
        SNMP messages carry PDUs associated with well defined specific
        protocol operations <xref target="RFC3416"/>. The PDUs can be
        used to classify SNMP messages. Following are a number of
        definitions that help to classify SNMP messages based on the
        PDU contained in them. These definitions will be used later on
        in this document.
      </t>
      <t>
        Notation: Let M be an SNMP message. The properties of M are
        denoted as follows:
      </t>
      <figure>
      <artwork><![CDATA[
   M.type    = operation type of message M (get, getnext, ...)
   M.class   = class of message M (according to RFC 3411)
   M.tsrc    = transport layer source endpoint of message M
   M.tdst    = transport layer destination endpoint of message M
   M.nsrc    = network layer source endpoint of message M
   M.ndst    = network layer destination endpoint of message M
   M.reqid   = request identifier of message M
   M.time    = capture timestamp of message M
   M.oids    = OIDs listed in varbind list of message M
   M.values  = values listed in varbind list of message M
   ]]></artwork>
      </figure>
      <t>
        Note that the properties of a message can be easily extracted
        from the exchange formats defined in RFC XXXX
        <xref target="ID-IRTF-NMRG-SNMP-MEASURE"/>.
      </t>

      <t>
        Definition (read request message): A read request message is a
        message M containing a PDU of type GetRequest, GetNextRequest,
        or GetBulkRequest.
      </t>

      <t>
        Definition (write request message): A write request message is
        a message M containing a PDU of type SetRequest.
      </t>

      <t>
        Definition (notification request message): A notification
        request message is a message M containing a PDU of type
        InformRequest.
      </t>

      <t>
        Definition (notification message): A notification message is a
        message M containing a PDU of type Trap or InformRequest.
      </t>

      <t>
        Definition (request message): A request message is a message M
        which is either a read request message, a write request
        message, or a notification request message.
      </t>
      
      <t>
        Definition (response message): A response message is a message
        M containing a PDU of type Response or of type Report.
      </t>

      <t>
        Note that Report messages are treated like Response messages
        since the SNMPv3 specifications currently use Report messages
        only as an error reporting mechanism, always triggered by the
        processing of some request messages. In case future SNMP
        versions or extensions use Report messages without having a
        request triggering the generation of Report messages, the
        definition above may need to be revisted.
      </t>

      <t>
        Definition (non-response message): A non-response message is a
        message M which is either a read request message, a write
        request message, or a notification message.
      </t>

      <t>
        Definition (command message): A command message is a message M
        which is either a read request message or a write request
        message.
      </t>

      <t>
        Definition (command group messages): A set of command group
        messages consists of all messages M satisfying either of the
        following two conditions:
      </t>
      <t>
        <list style='format (C%d) ' counter='command'>
          <t>M is a command message</t>
          <t>M is a response message and there exists a command
          message C such that the following holds:
          <figure>
            <artwork><![CDATA[
          M.reqid = C.reqid
          M.tdst  = C.tsrc
          M.tsrc  = C.tdst
          (M.time - C.time) < t
          ]]></artwork>
            </figure>
          </t>
        </list>
      </t>
      <t>
        The parameter t defines a maximum timeout for response messages.
      </t>

      <t>
        This definition requires that the response message originates
        from the transport endpoint over which the request message has
        been received. This is not strictly required by SNMP transport
        mappings and in particular the UDP transport mapping allows to
        send responses from different transport endpoints. While
        sending response messages from a different transport endpoint
        is legal, it is also considered bad practice causing
        interoperability problems since some management systems do not
        accept such messages.
      </t>
      <t>
        It was decided to require matching transport endpoints since
        doing so significantly simplifies the procedures below and
        avoids accidentally confusing requests and responses.
        Implementations responding from different transport endpoints
        will lead to (a) a larger number of requests without related
        responses (and likely no retries) and (b) a similarly large
        number of responses without a matching request. If such
        behavior can be detected, the traces should be investigated
        and if needed the transport endpoints corrected. Note that the
        requirement for matching transport endpoints only affects
        request / response pairs. It is perfectly fine for a manager
        use different transport layer endpoints in different polling
        instances.
      </t>

      <t>
        Definition (notification group messages): A set of
        notification group messages consists of all messages M
        satisfying either of the following two conditions:
      </t>
      <t>
        <list style='format (N%d) ' counter='notification'>
          <t>M is a notification message</t>
          <t>M is a response message and there exists a notification
          request message N such that the following holds:
            <figure>
              <artwork><![CDATA[
          M.reqid = N.reqid
          M.tdst  = N.tsrc
          M.tsrc  = N.tdst
          (M.time - N.time) < t
          ]]></artwork>
            </figure>
          </t>
        </list>
      </t>
      <t>
        The parameter t defines a maximum timeout for response messages.
      </t>

      <t>
        We again require that the transport endpoints match
        for notification group messages.
      </t>

    </section>

    <section anchor="traces" title="Traces">
      <t>
        Traces are (large) sets of SNMP messages that are the result
        of recording SNMP traffic using a single traffic recording
        unit (e.g., using tcpdump) on a network segment carrying
        traffic of one or more managers and agents. Traces being used
        in the remainder of this document may be altered as a result
        of anonymization, which may result in some message information
        loss.
      </t>
      <t>
        Definition (trace): An SNMP trace (or short "trace") T is an
        ordered set of zero or more SNMP messages M. All messages M in
        T are chronologically ordered according to the capture time
        stamp M.time.
      </t>
    </section>

    <section anchor="flows" title="Flows">
      <t>
	Traces may contain SNMP messages that have been exchanged
	between possibly many different network layer endpoints. One
	way of making an initial separation of such a trace into more
	manageable pieces is by splitting the messages into flows.
	Each flow contains only messages that have occurred between
	two network layer endpoints.
      </t>
      <t>
        Definition (flow): A flow F with parameter t is the set of
        messages of an SNMP trace T with the following properties:
      </t>
      <t>
        <list style='format (F%d) ' counter='flow'>
          <t>
            All response messages originate from a single network
            endpoint.
          </t>
          <t>
            All non-response messages originate from a single network
            endpoint.
          </t>
          <t>
            All messages are either command group messages with
            parameter t or notification group messages with parameter
            t.
          </t>
        </list>
      </t>
      <t>
	Parameter t defines the maximum timeout for response messages
	and is the same for both the notification group messages and
	the command group messages which a flow may consist of.
	Parameter t is the same for both cases, because they each may
	contain non-response messages that originate from a single
	network endpoint with one timeout characteristic. The value of
	t should be chosen such that only response messages to the
	respective non-response messages are considered part of the
	same flow. Analysis of a large number of traces shows that 25
	seconds is a proper default value for t.
      </t>
      <t>
        It is possible that response messages of a trace cannot be
        classified to belong to any flow. This can happen if request
        messages triggering the response messages were not recorded
        (for example due to asymmetric routing) or because response
        messages were originating from transport endpoints different
        from the endpoint used to receive the associated request
        message.
      </t>
      <t>
        Subsequently, we call flows containing only command group
        messages command flows. Similarly, we call flows containing
        only notification group messages notification flows.
      </t>
      <t>
        Definition (flow initiator): A flow initiator is the network
        endpoint of the two endpoints involved in a flow, which is
        responsible for sending the first non-response message.
      </t>
      <t>
        Notation: Let F be a flow as defined above. We denote the
        properties of F as follows:
      </t>
      <figure>
      <artwork><![CDATA[
   F.type  = type of the flow F (command/notification)
   F.nsrc  = network layer source endpoint of F
   F.ndst  = network layer destination endpoint of F
   F.start = time stamp of the first message in F
   F.end   = time stamp of the last message in F
   F.t     = parameter t of F (maximum timeout for response messages)
   ]]></artwork>
      </figure>
      <t>
	This definition of a flow is different from other flow
	definitions, for example, the NetFlow definition <xref
	target="RFC3954"/>. In particular, SNMP flows can be
	unidirectional (e.g., a manager sending non-response messages
	to a non-responding agent) and bidirectional (e.g., a manager
	reading a table from an agent).
      </t>
      <t>
        This flow definition is mostly consistent with the definition
        of an SNMP flow used in <xref target="SPHSM07"/>. The
        difference is that the tool used to generate the data reported
        in <xref target="SPHSM07"/> did only require that the network
        layer source endpoint of the response messages matches the
        destination network layer endpoint of the associated request
        messages.
      </t>

      <t>
	Following is an example of a trace consisting of SNMP messages
	that were sent between different network layer endpoints. The
	network layer endpoints are represented by A, B, C and D. This
	trace will be separated into flows.
      </t>
      <figure>
        <artwork><![CDATA[
 ----------------------------------------------------------------
 Message | Time [s] | Direction | PDU type        | Req. ID.
 ----------------------------------------------------------------
    0      0.0         A -> B     GetNext Request    1
    1      0.04        C -> D     Get Request       10
    2      0.05        B -> A     Response           1
    3      0.08        D -> C     Response          10
    4      0.11        A -> B     GetNext Request    2
    5      0.15        B -> A     Response           2
    6      0.18        A -> B     GetNext Request    3
    7      0.22        D -> C     Trap              14
    8      0.25        B -> A     Response           3
 ----------------------------------------------------------------
   ]]></artwork>
      </figure>
      <t>
	This trace contains SNMP messages that have been exchanged
	between different network layer endpoints. One flow will
	consist of SNMP messages that have been exchanged between
	network layer endpoints A and B, where all response messages
	originate from B and all non-response messages originate from
	A.
      </t>
      <figure>
        <artwork><![CDATA[
 ----------------------------------------------------------------
 Message | Time [s] | Direction | PDU type        | Req. ID.
 ----------------------------------------------------------------
    0      0.0         A -> B     GetNext Request    1
    2      0.05        B -> A     Response           1
    4      0.11        A -> B     GetNext Request    2
    5      0.15        B -> A     Response           2
    6      0.18        A -> B     GetNext Request    3
    8      0.25        B -> A     Response           3
 ----------------------------------------------------------------
   ]]></artwork>
      </figure>
      <t>
	A minimum value of parameter t of this flow is 0.07 seconds,
	since that is the longest time between a request and its
	subsequent response message.
      </t>
      <t>
	The second flow contains SNMP messages exchanged between
	network layer endpoints C and D, where all response messages
	originate from D and all non-response messages originate from
	C.
      </t>
      <figure>
        <artwork><![CDATA[
 ----------------------------------------------------------------
 Message | Time [s] | Direction | PDU type        | Req. ID.
 ----------------------------------------------------------------
    1      0.04        C -> D     Get Request       10
    3      0.08        D -> C     Response          10
 ----------------------------------------------------------------
   ]]></artwork>
      </figure>
      <t>
	A minimum value of parameter t for this flow is 0.04 seconds.
      </t>
      <t>
	The third and final flow contains the remaining SNMP messages
	of the trace that occurred between network layer endpoints C
	and D. In this case the non-response message originates from
	D.
      </t>
      <figure>
        <artwork><![CDATA[
 ----------------------------------------------------------------
 Message | Time [s] | Direction | PDU type        | Req. ID.
 ----------------------------------------------------------------
    7      0.22        D -> C     Trap              14
 ----------------------------------------------------------------
   ]]></artwork>
      </figure>
      <t>
	There is no parameter t applicable to this flow, because there
	are no response messages.
      </t>

    </section>

    <section anchor="slices" title="Slices">

      <t>
	Flows can still contain a large amount of SNMP messages. A
	flow should therefore be split up into even smaller sets of
	messages.  One way of identifying meaningful subsets of
	messages of a flow would be by considering the behavior of
	managers and agents. In the case of managers, they are usually
	configured to perform regular polling instances. In such a
	polling instance, the manager might poll a number of
	agents. Since a flow contains only the messages exchanged
	between two network layer endpoints, a flow therefore probably
	consists of only a subset of the messages that are part of a
	polling instance. So, one option of finding smaller,
	meaningful subsets of messages within flows, would be by
	looking for messages that belong to a particular polling
	instance. Such a smaller set of messages is called a slice.
      </t>
      <t>
        Definition (slice): A slice S with parameter e is a subset of
        SNMP messages in a flow F for which the following properties
        hold:
      </t>
      <t>
        <list style='format (S%d) ' counter='slice'>
          <t>
            All messages are exchanged between the same two transport
            endpoints (a single transport endpoint pair).
          </t>
          <t>
            All non-response messages must have a PDU of the same type.
          </t>
          <t>
            All messages with a PDU of type Get, Set, Trap, or Inform
            must contain the same set of OIDs.
          </t>
          <t>
            Each GetNext or GetBulk message must either contain the
            same set of OIDs or they must be linked to the
            chronologically last response of the previous request,
            that is the request must contain at least one OID that has
            been contained in the (repeater) varbind list of the
            chronologically last response message of a previous
            request message.
          </t>
          <t>
            All Response messages must follow a previous request
            message.
          </t>
          <t>
            For any two subsequent request messages Q1 and Q2 with
            Q1.time &lt; Q2.time, the following condition must hold:
            <figure>
              <artwork><![CDATA[
            (Q2.time - Q1.time) < e
            ]]></artwork>
            </figure>
          </t>
        </list>
      </t>

      <t>
	S1 requires that the messages of a single slice are exchanged
	between a single transport layer endpoint pair. This is
	different from the flow definition, which requires a single
	network layer endpoint pair.  The choice of looking at the
	transport layer endpoints in the case of slices is based on
	the assumption that, for instance, multiple managers and
	agents might be operating from the same respective network
	layer endpoint. Another assumption is that a manager and an
	agent will only use a single transport layer endpoint
	respectively when they communicate for the duration of a slice
	(i.e., polling instance). A previous section already mentioned
	some issues when a manager or agent uses different transport
	layer endpoints within a single polling instance.
      </t>
      <t>
        The parameter e in S6 defines the maximum time between two
        non-response messages that belong to a slice. This parameter
        should be chosen such that unrelated requests within a flow
        are not considered to be of the same slice (i.e., it is used
        to detect the end of a slice). Unrelated requests are those
        that, for instance, belong to different polling instances. The
        parameter e should therefore be larger than the retransmission
        interval in order to keep retransmissions within a slice and
        smaller than the polling interval used by the slice initiator.
      </t>
      <t>
	The value of parameter e might be closely related to parameter
	t of the respective flow the slice is part of. For instance,
	if parameter e is very large, than t is likely to be also very
	large and vice versa. Also, if parameter e is very small, than
	t is probably also very small. However, it is not possible to
	strictly state that e and t are always closely related to each
	other, because parameter e is specific for a slice. This is in
	contrast with parameter t which is specific for a much larger
	set of messages, a flow.
      </t>

      <t>
        Definition (slice initiator): A slice initiator is one of the
        two transport endpoints involved in a slice, which is
        responsible for sending the chronologically first non-response
        message.
      </t>

      <t>
        Notation: A slice S has several properties. We introduce the
        following notation:
      </t>
      <figure>
        <artwork><![CDATA[
   S.type     = type of non-response messages in S
   S.tsrc     = transport layer endpoint of initiator of S
   S.tdst     = transport layer endpoint of non-initiator of S
   S.start    = time stamp of the chronologically first message in S
   S.end      = time stamp of the chronologically last message in S
   S.e        = parameter e of S (maximum time between two 
                non-response messages)
   ]]></artwork>
      </figure>
      <t>
	Following is an example of a flow F consisting of SNMP
	messages that have taken place between transport later
	endpoints A, B, C and D.  Note that even though there are
	multiple transport layer endpoints, it still means that within
	this single flow only two network layer endpoints can be
	identified.
      </t>
      <figure>
	<artwork><![CDATA[
 -------------------------------------------------------------------
 Message | Time [s] | Direction | PDU type       | Req. ID | OIDs
 -------------------------------------------------------------------
    0         0.0       A -> B    GetNext Request   1        alpha
    1         0.05      B -> A    Response          1        alpha.1
    2         0.11      A -> B    GetNext Request   2        alpha.1
    3         0.15      B -> A    Response          2        alpha.2
    4         0.18      A -> B    GetNext Request   3        alpha.2
    5         0.25      B -> A    Response          3        beta.1
    6       300.0       C -> D    GetNext Request   4        alpha
    7       300.06      D -> C    Response          4        alpha.1
    8       300.14      C -> D    GetNext Request   5        alpha.1
    9       300.21      D -> C    Response          5        alpha.2
   10       300.28      C -> D    GetNext Request   6        alpha.2
   11       300.32      D -> C    Response          6        beta.1
 -------------------------------------------------------------------
	]]></artwork>
      </figure>
      <t>
	This flow contains SNMP messages that have been exchanged
	between two different pairs of transport layer endpoints.
	According to S1, this means that the set of messages in this
	flow can be separated into at least two sets of messages that
	might be slices:
      </t>
      <figure>
        <artwork><![CDATA[
 -------------------------------------------------------------------
 Message | Time [s] | Direction | PDU type       | Req. ID | OIDs
 -------------------------------------------------------------------
    0         0.0       A -> B    GetNext Request   1        alpha
    1         0.05      B -> A    Response          1        alpha.1
    2         0.11      A -> B    GetNext Request   2        alpha.1
    3         0.15      B -> A    Response          2        alpha.2
    4         0.18      A -> B    GetNext Request   3        alpha.2
    5         0.25      B -> A    Response          3        beta.1
 -------------------------------------------------------------------
        ]]></artwork>
      </figure>
      <figure>
        <artwork><![CDATA[
 -------------------------------------------------------------------
 Message | Time [s] | Direction | PDU type       | Req. ID | OIDs
 -------------------------------------------------------------------
    6       300.0       C -> D    GetNext Request   4        alpha
    7       300.06      D -> C    Response          4        alpha.1
    8       300.14      C -> D    GetNext Request   5        alpha.1
    9       300.21      D -> C    Response          5        alpha.2
   10       300.28      C -> D    GetNext Request   6        alpha.2
   11       300.32      D -> C    Response          6        beta.1
 -------------------------------------------------------------------
	]]></artwork>
      </figure>
      <t>
	S2 does not result in a further separation of these sets into
	smaller sets of SNMP messages that might be slices. This,
	because all the listed non-response messages are of the same
	PDU type. Neither is S3 affecting the current sets.
      </t>
      <t>
	S4 also does not result in a further subdivision of these two
	sets, because in each of the two sets the non-response
	messages, that have preceding response messages, have the same
	OID in their varbind list as the respective preceding
	response. For example, the second and third non-response
	message in both sets have the same OID compared to the
	respective preceding response message (i.e., these
	non-response messages are a part of a single polling
	instance).
      </t>
      <t>
	S5 also does not affect these two sets, because both sets
	already contain only response messages that are the result of
	a non-response message that occurred before each response
	message respectively (i.e., each response has a request
	identifier that is the same as the request identifier of a
	non-response messages listed before that response message).
      </t>
      <t>
	S6 states that parameter e should be chosen such that
	unrelated requests within a flow are not considered to be of
	the same slice.  Considering the given flow and its messages,
	a proper value for e should be 0.14 &lt;= e &lt; 299.82
	seconds. Such a value for parameter e will separate the flow
	into two apparent polling instances, which each contain the
	same set of messages as those two listed above.
      </t>
      <t>
	As a result, the two listed sets are also slices. The given
	flow thus consists of the following two slices with the value
	of parameter e as defined above.
      </t>
      <t>
	Following is an example of a flow F consisting of SNMP
	messages that have taken place between transport later
	endpoints A, B and C.  Note again that even though there are
	multiple transport layer endpoints, it still means that within
	this single flow only two network layer endpoints can be
	identified.
      </t>
      <figure>
        <artwork><![CDATA[
 -------------------------------------------------------------------
 Message | Time [s] | Direction | PDU type       | Req. ID | OIDs
 -------------------------------------------------------------------
    0         0.0       A -> B    Get Request       1        alpha.1
    1         0.06      B -> A    Response          1        alpha.1
    2         0.12      A -> B    Get Request       2        beta.1
    3         0.17      B -> A    Response          2        beta.1
    4       300.0       A -> B    Get Request       3        alpha.1
    5       300.05      B -> C    Trap             10        gamma.1
    6       300.07      B -> A    Response          3        alpha.1
    7       300.14      A -> B    Get Request       4        beta.1
    8       300.19      B -> A    Response          4        beta.1
 -------------------------------------------------------------------
	]]></artwork>
      </figure>
      <t>
	This flow contains messages that are exchanged between
	different pairs of transport layer endpoints. Two different
	pairs of transport layer endpoints are used within this
	flow. According to S1, this means that at least two sets of
	messages might be slices:
      </t>
      <figure>
        <artwork><![CDATA[
 -------------------------------------------------------------------
 Message | Time [s] | Direction | PDU type       | Req. ID | OIDs
 -------------------------------------------------------------------
    0         0.0       A -> B    Get Request       1        alpha.1
    1         0.06      B -> A    Response          1        alpha.1
    2         0.12      A -> B    Get Request       2        beta.1
    3         0.17      B -> A    Response          2        beta.1
    4       300.0       A -> B    Get Request       3        alpha.1
    6       300.07      B -> A    Response          3        alpha.1
    7       300.14      A -> B    Get Request       4        beta.1
    8       300.19      B -> A    Response          4        beta.1
 -------------------------------------------------------------------
	]]></artwork>
      </figure>
      <figure>
        <artwork><![CDATA[
 -------------------------------------------------------------------
 Message | Time [s] | Direction | PDU type       | Req. ID | OIDs
 -------------------------------------------------------------------
    5       300.05      B -> C    Trap             10        gamma.1
 -------------------------------------------------------------------
	]]></artwork>
      </figure>
      <t>
	Applying S2 to each of the two sets does not result in more
	sets, because each set only contains non-response messages of
	one PDU type respectively.
      </t>
      <t>
	S3 requires separating the first set of SNMP messages into two
	sets, because the Get Request messages must have the same set
	of OIDs.  This results in the following three sets of SNMP
	messages.
      </t>
      <figure>
        <artwork><![CDATA[
 -------------------------------------------------------------------
 Message | Time [s] | Direction | PDU type       | Req. ID | OIDs
 -------------------------------------------------------------------
    0         0.0       A -> B    Get Request       1        alpha.1
    1         0.06      B -> A    Response          1        alpha.1
    4       300.0       A -> B    Get Request       3        alpha.1
    6       300.07      B -> A    Response          3        alpha.1
 -------------------------------------------------------------------
	]]></artwork>
      </figure>
      <figure>
        <artwork><![CDATA[
 -------------------------------------------------------------------
 Message | Time [s] | Direction | PDU type       | Req. ID | OIDs
 -------------------------------------------------------------------
    2         0.12      A -> B    Get Request       2        beta.1
    3         0.17      B -> A    Response          2        beta.1
    7       300.14      A -> B    Get Request       4        beta.1
    8       300.19      B -> A    Response          4        beta.1
 -------------------------------------------------------------------
	]]></artwork>
      </figure>
      <figure>
        <artwork><![CDATA[
 -------------------------------------------------------------------
 Message | Time [s] | Direction | PDU type       | Req. ID | OIDs
 -------------------------------------------------------------------
    5       300.05      B -> C    Trap             10        gamma.1
 -------------------------------------------------------------------
	]]></artwork>
      </figure>
      <t>
	S4 is not applicable to either of these sets.
      </t>
      <t>
	S5 does not affect these sets, because these sets already
	contain only response messages that are the result of a
	non-response message that occurred before each response
	message respectively.
      </t>
      <t>
	Finally, S6 states that parameter e should be chosen such that
	unrelated requests within a flow are not considered to be of
	the same slice. The messages in the given flow suggest that
	two polling instances might have occurred. Therefore, an
	appropriate value for parameter e would be &lt; 300 seconds.
	The determination of parameter e results in the separation of the
	first two sets into two sets each. Following are the resulting
	slices.
      </t>
      <figure>
        <artwork><![CDATA[
 -------------------------------------------------------------------
 Message | Time [s] | Direction | PDU type       | Req. ID | OIDs
 -------------------------------------------------------------------
    0         0.0       A -> B    Get Request       1        alpha.1
    1         0.06      B -> A    Response          1        alpha.1
 -------------------------------------------------------------------
	]]></artwork>
      </figure>
      <figure>
        <artwork><![CDATA[
 -------------------------------------------------------------------
 Message | Time [s] | Direction | PDU type       | Req. ID | OIDs
 -------------------------------------------------------------------
    2         0.12      A -> B    Get Request       2        beta.1
    3         0.17      B -> A    Response          2        beta.1
 -------------------------------------------------------------------
	]]></artwork>
      </figure>
      <figure>
        <artwork><![CDATA[
 -------------------------------------------------------------------
 Message | Time [s] | Direction | PDU type       | Req. ID | OIDs
 -------------------------------------------------------------------
    4       300.0       A -> B    Get Request       3        alpha.1
    6       300.07      B -> A    Response          3        alpha.1
 -------------------------------------------------------------------
	]]></artwork>
      </figure>
      <figure>
        <artwork><![CDATA[
 -------------------------------------------------------------------
 Message | Time [s] | Direction | PDU type       | Req. ID | OIDs
 -------------------------------------------------------------------
    7       300.14      A -> B    Get Request       4        beta.1
    8       300.19      B -> A    Response          4        beta.1
 -------------------------------------------------------------------
	]]></artwork>
      </figure>
      <figure>
        <artwork><![CDATA[
 -------------------------------------------------------------------
 Message | Time [s] | Direction | PDU type       | Req. ID | OIDs
 -------------------------------------------------------------------
    5       300.05      B -> C    Trap             10        gamma.1
 -------------------------------------------------------------------
	]]></artwork>
      </figure>

    </section>

    <section anchor="slice-prefix" title="Slice Prefix">
      <t>
        As noted in the beginning of this document, it is desired that
        slices can be tested for equality/comparability. This is where
        the slice prefix comes in. The slice prefix has as a sole
        purpose to provide one of the means to compare slices. Using
        the slice prefix and a few other parameters (which will be
        discussed later on in this document) of a number of slices,
        one can determine which slices should be considered 'equal'
        and which of them are incomparable. This will assist in the
        process of finding potentially other relations.
      </t>
      <t>
        The slice prefix is a set of OIDs. This set is constructed
        from the messages that make up a single slice. So, for
        example, a slice that is the result of a manager requesting
        the contents of a particular table (with OID alpha) on an
        agent using a simple single varbind GetNext walk, starting at
        the table OID alpha, shall yield a slice prefix which consists
        of the OID alpha.
      </t>
      <t>
        Because the aim is to compare various slices using the slice
        prefix (along some other characteristics of a slice), this
        implicitly suggests the need to know whether a number of
        slices are the result of the same behaviour (i.e., specific
        configuration) of the initiating party of these slices. For
        example, one may want to know whether a number slices that
        involve a single manager and a single agent were the result of
        just one specific configuration of that manager. Multiple
        slices, that may all be initiated by that same manager and
        each slice possibly occurred in different polling instances,
        may in fact be the result of the same specific configuration
        of that particular manager. So, since in this case the
        specific configuration of the manager is only relevant for
        determining the behaviour, the slice prefix should be
        constructed based on OIDs in messages originating from that
        manager only. More generally, only the messages within slices
        that are sent by the initiating party (the non-response
        messages) are considered for the determination of the
        respective slice prefix of a slice.
      </t>
      <t>
        The resulting set of OID prefixes will represent the behaviour
        of the respective initiating party of that slice. This allows
        us to compare different slices.
      </t>
      <t>
        Following is a short introductory example which depicts what a
        slice could consist of and how one could determine the slice
        prefix in such a general case.
      </t>
      <t>
        Consider the case of a single manager A polling a specific
        agent B. More specifically, the manager A is configured to
        retrieve the complete contents of two columns alpha and beta
        of a some table. The resulting slice may contain the following
        messages:
      </t>
      <figure>
        <artwork><![CDATA[
 -------------------------------------------------------------------
 Message | Direction | PDU type        | OIDs
 -------------------------------------------------------------------
    0        A -> B    GetNext Request   alpha, beta
    1        B -> A    Response          alpha.1, beta.1
    2        A -> B    GetNext Request   alpha.1, beta.1
    3        B -> A    Response          alpha.2, beta.2
    4        A -> B    GetNext Request   alpha.2, beta.2
    5        B -> A    Response          gamma.1, delta.1
 -------------------------------------------------------------------
   ]]></artwork>
      </figure>
      <t>
        The manager starts with a GetNext request referencing two
        OIDs, alpha and beta. The agent B replies in message 1 with
        the first items of each of the referenced columns. The manager
        in turn goes on obtaining data from these two columns until it
        receives message 5, which indicates that the manager has
        received all of the data from the two columns.
      </t>
      <t>
        It can be easily concluded that the manager was configured to
        retrieve the contents of the two columns alpha and beta (the
        slice prefix). A different slice involving the same manager
        and agent and that is again the result of the same
        configuration of the manager, should be considered 'equal' to
        this one because the two slices are the result of the same
        behaviour. It should however be mentioned that such a second
        slice might contain a different number of messages, since the
        contents of the tables on the agent side might have changed
        over time. This underlines the previously made remark that
        only the messages originating from the initiating party should
        be considered in this process, because they will (in such a
        scenario) always illustrate the same behaviour of the
        initiating party.
      </t>
      <t>
        The previous example now makes it possible to give a more
        formal definition of a slice prefix. This is accomplished by
        first defining a slice signature which then leads to the
        definition of a slice prefix.
      </t>

      <t>
	Definition (slice signature): A slice signature S.sig of a
	slice S is a set of OIDs derived from the OIDs contained in
	the non-response messages of a slice.  This set S.sig consists
	of the following OIDs:
            <figure>
              <artwork><![CDATA[
case S.type = GetNext or S.type = GetBulk:

     S.sig =       U    (N.oids)  -      U    (R.oids)
                 N in S                R in S
             N is non-response      R is response

otherwise:

     S.sig =       U   (N.oids)
                 N in S
             N is non-response
		]]></artwork>
            </figure>
      </t>
      
      <t>
	Definition (OID prefix): An OID a = a_1.a_2...a_n is a prefix
	of OID b = b_1.b_2...b_m if and only if
	<list style='format (P%d) ' counter='prefix'>
	  <t>n &lt; m and</t>
	  <t>a_i = b_i for 1 &lt;= i &lt;= n.</t>
	</list>
      </t>

      <t>
	Definition (slice prefix): The slice prefix S.slice is the set
	of all OIDs o in S.sig for which there is no p in S.sig such
	that p is a prefix of o.
      </t>

<!--
   Note that this definition is equal to the definition of the slice
   prefix with the additional requirement that no OID in S.sig is a
   child of any other OID in S.sig.

   This definition states that all OIDs in the first non-response
   message are considered part of the resulting slice signature S.sig.
   In addition to that, S.sig also contains those OIDs that have been
   newly introduced in non-response messages (that occurred later than
   the first one). Newly introduced OIDs are considered as such if they
   were not included in any of the responses. Besides that, all newly
   introduced OIDs that are a child OID of any of the OIDs in S.sig,
   shall not be considered part of S.sig. An example where this would
   be the case is newly introduced OID 1.2.3.4 where 1.2.3 is already
   in S.sig. The reason for this will become apparent in the sequel.
-->

      <t>
        Following is an example to illustrate the definitions just
        described: Consider the case that a single manager A polling
        an agent B. More specifically, the manager A is programmed to
        retrieve the complete contents of two single column tables
        alpha and beta. Besides that, the manager now also requests
        the sysUpTime in the first request the manager sends to B. A
        resulting slice may contain the following messages:
      </t>
      <figure>
        <artwork><![CDATA[
 -------------------------------------------------------------------
 Message | Direction | PDU type        | OIDs
 -------------------------------------------------------------------
    0        A -> B    GetNext Request   sysUpTime, alpha, beta
    1        B -> A    Response          sysUpTime.0, alpha.1, beta.1
    2        A -> B    GetNext Request   alpha.1, beta.1
    3        B -> A    Response          alpha.2, beta.2
    4        A -> B    GetNext Request   alpha.2, beta.2
    5        B -> A    Response          gamma.1, delta.1
 -------------------------------------------------------------------
   ]]></artwork>
      </figure>
      <t>
        The slice prefix is determined as follows:
	<list style="numbers">
	  <t>
	    The union of all OIDs in non-response messages is the
	    following set:
	    <figure>
	      <artwork><![CDATA[
       N = { sysUpTime, alpha, beta, 
             alpha.1, beta.1, alpha.2, beta.2 }
              ]]></artwork>
            </figure>
          </t>
          <t>
            The union of the OIDs in response messages is the the
            following set:
            <figure>
              <artwork><![CDATA[
       R = { sysUpTime.0, alpha.1, beta.1,
             alpha.2, beta.2, gamma.1, delta.1 }
              ]]></artwork>
            </figure>
          </t>
          <t>
            Substracting the two sets results in the slice signature
            S.sig:
            <figure>
              <artwork><![CDATA[
       S.sig = N - R = { sysUpTime, alpha, beta }
              ]]></artwork>
            </figure>
          </t>
	  <t>
	    Since none of the OIDs in S.sig is a prefix of any other
	    OID in S.sig, the slice prefix is equal to the slice
	    signature:
            <figure>
              <artwork><![CDATA[
       S.prefix = { sysUpTime, alpha, beta }
              ]]></artwork>
            </figure>
	  </t>
	</list>
      </t>
      <t>
	This set of OIDs describes the behavior of the initiating
	party of this particular slice. Within the context of the
	described configuration of the initiating party is it apparent
	that a subsequent polling instance of the mentioned manager A
	polling agent B will result in the same slice signature.
      </t>

      <t>
        Following is a more elaborate slice for which the slice prefix
        is determined. Consider again the case that a single manager A
        is set to poll a specific agent B. Manager A is programmed to
        retrieve some values from B. A single slice may contain the
        following messages:
      </t>
      <figure>
        <artwork><![CDATA[
 -------------------------------------------------------------------
 Message | Direction | PDU type        | OIDs
 -------------------------------------------------------------------
    0        A -> B    GetNext Request   alpha, beta
    1        B -> A    Response          alpha.1, beta.1
    2        A -> B    GetNext Request   alpha.1, beta.1
    3        B -> A    Response          alpha.2, beta.3
    4        A -> B    GetNext Request   beta.2, alpha.2,
                                         sysUpTime
    5        B -> A    Response          beta.3, alpha.3
                                         sysUpTime.0
    6        A -> B    GetNext Request   beta.3, alpha.3
    7        B -> A    Response          gamma.1, alpha.4
    8        A -> B    GetNext Response  alpha.4
    9        B -> A    Response          delta.1
 -------------------------------------------------------------------
   ]]></artwork>
      </figure>
      <t>
	This slice has a number of interesting properties:
	<list style="symbols">
	  <t>Not all columns in the table have an equal length.</t>
	  <t>The manager is set to request the sysUpTime on an
	  irregular basis (i.e., every few requests).</t>
	  <t>The manager attempts to 'fill' holes in the table.</t>
	  <t>The order of referenced OIDs in GetNext messages changes.</t>
	</list>
      </t>
      <t>
	All of these properties do not influence the process for
	determining the slice signature. The slice prefix is
	constructed as follows:
	<list style="numbers">
	  <t>
	    The union of all OIDs in non-response messages is the
	    following set:
	    <figure>
	      <artwork><![CDATA[
       N = { alpha, beta, alpha.1, beta.1, 
             beta.2, alpha.2, sysUpTime, beta.3, alpha.3, alpha.4 }
              ]]></artwork>
            </figure>
          </t>
          <t>
            The union of the OIDs in response messages is the the
            following set:
            <figure>
              <artwork><![CDATA[
       R = { alpha.1, beta.1, alpha.2, beta.3, alpha.3,
             sysUpTime.0, gamma.1, alpha.4, delta.1 }
              ]]></artwork>
            </figure>
          </t>
          <t>
            Substracting the two sets results in the slice signature
            S.sig:
            <figure>
              <artwork><![CDATA[
       S.sig = N - R = { alpha, beta, beta.2, sysUpTime }
              ]]></artwork>
            </figure>
	    The element beta.2 exists because the manager was trying
	    to 'fill' a 'hole' in a table. Since these holes reside in
	    the tables on the agent side and may change dynamically,
	    they do not really help in describing the behavior of the
	    initiating party.
          </t>
	  <t>
	    Since beta is a prefix of beta.2, the slice prefix becomes
	    the following set:
            <figure>
              <artwork><![CDATA[
       S.prefix = { alpha, beta, sysUpTime }
              ]]></artwork>
            </figure>
	    The slice prefix does not include beta.2 anymore and thus
	    a manager retrieving the same columns alpha and beta with
	    and without holes will produce slices with the same slice
	    prefix.
	  </t>
	</list>
      </t>
      <t>
	Finally, consider a slice where s.type is not GetBulk or
	GetNext. Manager A is programmed to poll some values from B. A
	single slice may contain the following messages:
      </t>
      <figure>
        <artwork><![CDATA[
 -------------------------------------------------------------------
 Message | Direction | PDU type        | OIDs 
 ------------------------------------------------------------------- 
    0        A -> B    Get Request       alpha.1, beta.1
    1        B -> A    Response          alpha.1, beta.1
   ]]></artwork>
      </figure>
      <t>
	The slice prefix is determined as follows:
	<list style="numbers">
	  <t>
	    The slice signature is the union of all OIDs in
	    non-response messages:
            <figure>
              <artwork><![CDATA[
       S.sig = { alpha.1, beta.1 }
              ]]></artwork>
            </figure>
	  </t>
	  <t>
	    Since none of the OIDs in S.sig is a prefix of any other
	    OID in S.sig, the slice prefix is equal to the slice
	    signature:
            <figure>
              <artwork><![CDATA[
       S.prefix = { alpha.1, beta.1 }
              ]]></artwork>
            </figure>
	  </t>
	</list>
      </t>

    </section>

    <section anchor="slice-type" title="Slice Type">

      <t>
        As described previously, the slice type allows for comparing
        slices. This means that any number of slices that are of the
        same slice type may be considered an equivalence class and may
        therefore be considered to be the result of the same behaviour
        of the slice initiator.
      </t>
      <t>
        Definition (slice equivalence): Two slices A and B satisfy the
        binary slice equivalence relation A ~ B if the following
        properties hold:
      </t>
      <t>
        <list style='format (EQ%d) ' counter='sliceequiv'>
          <t>
            All messages in A and B have been exchanged between the
            same two network layer endpoints.
          </t>
          <t>
            All read request messages, write request messages, and
            notification messages in A and B originate from the same
            network layer endpoint.
          </t>
          <t>
            All non-response messages in A and B are of the same type.
          </t>
          <t>
            The slices A and B have the same prefix, that is A.prefix
            = B.prefix.
          </t>
        </list>
      </t>
      <t>
	It can be easily seen that the relation ~ is reflexive,
	symmetric, and transitive and thus forms an equivalence
	relation between slices.
      </t>
      <t>
	Definition (slice type): Let S be a set of slices, then all
	slices in the equivalence class [A] = {s in S | s ~ A} with A
	in S, are of the same slice type.
      </t>
      <t>
	Following are two slices that are of the same equivalence
	class and are therefore of the same slice type.
      </t>
      <t>
	The first slice contains messages that have been exchanged
	between transport layer endpoints A and B.
      </t>
      <figure>
        <artwork><![CDATA[
 -------------------------------------------------------------------
 Message | Direction | PDU type        | OIDs
 -------------------------------------------------------------------
    0        A -> B    GetNext Request   alpha, beta
    1        B -> A    Response          alpha.1, beta.1
    2        A -> B    GetNext Request   alpha.1, beta.1
    3        B -> A    Response          alpha.2, beta.2
    4        A -> B    GetNext Request   alpha.2, beta.2
    5        B -> A    Response          gamma.1, delta.1
 -------------------------------------------------------------------
   ]]></artwork>
      </figure>
      <t>
	The second slice contains messages that have been exchanged
	between transport layer endpoints C and D. However, the
	network layer endpoints of this slice are the same as the
	first slice and all non-response messages in both slices
	originate from the same network layer endpoint.
      </t>
      <figure>
        <artwork><![CDATA[
 -------------------------------------------------------------------
 Message | Direction | PDU type        | OIDs
 -------------------------------------------------------------------
    0        C -> D    GetNext Request   alpha, beta
    1        D -> C    Response          alpha.1, beta.1
    2        C -> D    GetNext Request   alpha.1, beta.1
    3        D -> C    Response          alpha.2, beta.2
    4        C -> D    GetNext Request   alpha.2, beta.2
    3        D -> C    Response          alpha.3, beta.3
    4        C -> D    GetNext Request   alpha.3, beta.3
    5        D -> C    Response          gamma.1, delta.1
 -------------------------------------------------------------------	
	]]></artwork>
      </figure>
      <t>
	EQ1 requires that both slices have occurred between the same
	two network layer endpoints, which is the case here.
      </t>
      <t>
	EQ2 requires that all read request messages, write request
	messages, and notification messages (i.e., all non-response
	messages) originate from the same network layer endpoint,
	which is the case.
      </t>
      <t>
	EQ3 is met, because all non-response messages are of PDU type
	GetNext Request in both cases.
      </t>
      <t>
	Using the definition of a slice prefix as stated in the
	previous chapter, it can be determined that both slices have
	the prefix { alpha, beta }. As a result, also EQ4 is met.
      </t>
      <t>
	Both slices are therefore part of the same equivalence class
	and are therefore of the same slice type.
      </t>
    </section>

    <section anchor="walks" title="Walks">

      <t>
        Definition (walk): A walk W is a slice S with the following
        properties:
      </t>
      <t>
        <list style='format (W%d) ' counter='walk'>
          <t>
            The type S.type of the slice S is either GetNext request
            or GetBulk request.
          </t>
          <t>
            At least one OID in the sequence of requests at the same
            varbind index must be increasing lexicographically while
            all OIDs at the same varbind index have to be
            non-decreasing.
          </t>
        </list>
      </t>

      <t>
        Definition (strict walk): A walk W is a strict walk if all
        OIDs in the sequence of requests at the same varbind index are
        strictly increasing lexicographically.  Furthermore, the OIDs
        at the same index of a response and a subsequent request must
        be identical.
      </t>

      <t>
        Definition (prefix constrained walk): A walk W is a prefix
        constrained walk if all OIDs at the same index in the request
        have the same OID prefix.  This prefix is established by the
        first request within the walk.
      </t>
      <t>
	Following is an example of a slice that is also a walk.
      </t>
      <figure>
        <artwork><![CDATA[
 -------------------------------------------------------------------
 Message | Direction | PDU type        | OIDs
 -------------------------------------------------------------------
    0        A -> B    GetNext Request   alpha, beta
    1        B -> A    Response          alpha.1, beta.1
    2        A -> B    GetNext Request   alpha.1, beta.1
    3        B -> A    Response          alpha.2, beta.2
    4        A -> B    GetNext Request   alpha.2, beta.2
    5        B -> A    Response          gamma.1, delta.1
 -------------------------------------------------------------------
   ]]></artwork>
      </figure>
      <t>
	This slice is a walk, because it adheres to W1, since it
	contains only requests that are of PDU type GetNext
	Request. W2 is also met, because there are always two object
	identifiers at the same varbind index that are increasing
	lexicographically in the sequence of requests. Also, none of
	the object identifiers at the same varbind index is
	lexicographically decreasing.
      </t>
      <t>
	This slice is also a strict walk, because all object
	identifiers in the sequence of requests at the same varbind
	index are strictly increasing lexicographically. Secondly, the
	object identifiers at the same index of a response and a
	subsequent request are always identical.
      </t>
      <t>
	Finally, this walk is also a prefix constrained walk, because
	all object identifiers at the same index in the request have
	the same object identifier prefix. The first varbind index in
	the requests always has alpha as prefix and the second varbind
	index always has beta as prefix.
      </t>

    </section>

    <section anchor="concurrency" title="Concurrency">

      <t>
        Definition (concurrency): Two slices A and B of a given flow F
        are concurrent at time t if A.start &lt;= t &lt;= A.end and
        B.start &lt;= t &lt;= B.end.
      </t>
      <t>
        Definition (flow concurrency level): The concurrency level of
        a flow F at time t is given by the number of concurrent slices
        of F at time t.
      </t>
      <t>
	Definition (slice initiator concurrency level): The
	concurrency level of a slice initiator I at time t is given by
	the number of concurrent slices initiated by the slice
	initiator I at time t.
      </t>
      <t>
	Definition (overlapping): Two slices A and B of a given flow F
	are called overlapping if there exists a time t where A and B
	are concurrent.
      </t>
      <t>
        Definition (delta time serial): Two slices A and B of a given
        flow F with B.start > A.end are called delta time serial if
        (B.start - A.end) &lt; delta.
      </t>

    </section>

    <section anchor="security" title="Security Considerations">
      <t>
        This document provides definitions for the analysis of SNMP
        traces and does not impact the security of the Internet.
      </t>
    </section>

    <section anchor="iana" title="IANA Considerations">
      <t>
        This document has no actions for IANA.
      </t>
    </section>

    <section title="Acknowledgements">
      <t>
        This document was influenced by discussions within the Network
        Management Research Group (NMRG).
      </t>
      <t>
        Part of this work was funded by the European Commission under
        grant FP6-2004-IST-4-EMANICS-026854-NOE.
      </t>
    </section>

  </middle>



  <back>


    <references title="Normative References">

      <reference anchor="RFC3411">
        <front>
          <title>
            An Architecture for Describing Simple Network Management
            Protocol (SNMP) Management Frameworks
          </title>
          <author initials="D." surname="Harrington" fullname="D. Harrington">
            <organization>Enterasys Networks</organization>
          </author>
          <author initials="R." surname="Presuhn" fullname="R. Presuhn">
            <organization>BMC Software, Inc.</organization>
          </author>
          <author initials="B." surname="Wijnen" fullname="B. Wijnen">
            <organization>Lucent Technologies</organization>
          </author>
          <date month="December" year="2002"/>
        </front>
        <seriesInfo name="RFC" value="3411"/>
      </reference>

      <reference anchor="RFC3416">
        <front>
          <title>
            Version 2 of the Protocol Operations for
            the Simple Network Management Protocol (SNMP)
          </title>
          <author initials="R." surname="Presuhn" fullname="R. Presuhn">
            <organization>BMC Software, Inc.</organization>
          </author>
          <date month="December" year="2002"/>
        </front>
        <seriesInfo name="RFC" value="3416"/>
      </reference>

    </references>


    <references title="Informative References">

      <reference anchor="RFC3410">
        <front>
          <title>
            Introduction and Applicability Statements for
            Internet Standard Management Framework
          </title>
          <author initials="J." surname="Case" fullname="J. Case">
            <organization>SNMP Research, Inc.</organization>
          </author>
          <author initials="R." surname="Mundy" fullname="R. Mundy">
            <organization>Network Associates Laboratories</organization>
          </author>
          <author initials="D." surname="Partain" fullname="D. Partain">
            <organization>Ericsson</organization>
          </author>
          <author initials="B." surname="Stewart" fullname="B. Stewart">
            <organization>Retired</organization>
          </author>
          <date month="December" year="2002"/>
        </front>
        <seriesInfo name="RFC" value="3410"/>
      </reference>

      <reference anchor="RFC3954">
        <front>
          <title>
	    Cisco Systems NetFlow Services Export Version 9
          </title>
          <author initials="B." surname="Claise" fullname="B. Claise">
            <organization>Cisco Systems, Inc.</organization>
          </author>
          <date month="October" year="2004"/>
        </front>
        <seriesInfo name="RFC" value="3954"/>
      </reference>

      <reference anchor="ID-IRTF-NMRG-SNMP-MEASURE">
        <front>
          <title>
            SNMP Traffic Measurements and Trace Exchange Formats
          </title>
          <author initials="J." surname="Schoenwaelder" fullname="Juergen Schoenwaelder">
            <organization>Jacobs University Bremen</organization>
          </author>
          <date month="February" year="2008"/>
        </front>
        <seriesInfo name="ID" value="draft-irtf-nmrg-snmp-measure-03.txt"/>
      </reference>

      <reference anchor="SPHSM07">
        <front>
          <title>
            SNMP Traffic Analysis: Approaches, Tools, and First Results
          </title>
          <author initials="J." surname="Schoenwaelder" fullname="Juergen Schoenwaelder">
            <organization>TU Braunschweig</organization>
          </author>
          <author initials="A." surname="Pras" fullname="A. Pras">
            <organization>University of Twente</organization>
          </author>
          <author initials="M." surname="Harvan" fullname="M. Harvan">
            <organization>International University Bremen</organization>
          </author>
          <author initials="J." surname="Schippers" fullname="J. Schippers">
            <organization>University of Twente</organization>
          </author>
          <author initials="R." surname="van de Meent" fullname="R. van de Meent">
            <organization>University of Twente</organization>
          </author>
          <date month="May" year="2007"/>
        </front>
        <seriesInfo name="IFIP/IEEE Integrated Management" value="IM 2007"/>
      </reference>

    </references>

  </back>
    

</rfc>

<!-- Local Variables:                                           -->
<!-- compile-command: "xml2rfc definitions.xml"                 -->
<!-- ispell-local-dictionary: "american"                        -->
<!-- sgml-declaration: "/usr/lib/sgml/declaration/xml.decl"     -->
<!-- sgml-omittag:nil                                           -->
<!-- sgml-shorttag:t                                            -->
<!-- sgml-namecase-general:t                                    -->
<!-- sgml-minimize-attributes:nil                               -->
<!-- sgml-always-quote-attributes:t                             -->
<!-- sgml-indent-step:2                                         -->
<!-- sgml-indent-data:t                                         -->
<!-- sgml-parent-document:nil                                   -->
<!-- sgml-exposed-tags:nil                                      -->
<!-- sgml-local-catalogs:nil                                    -->
<!-- sgml-local-ecat-files:nil                                  -->
<!-- End:                                                       -->
